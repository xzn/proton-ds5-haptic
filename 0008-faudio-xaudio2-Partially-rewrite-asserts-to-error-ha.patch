From 14e9ac6bf2fd64eb4e55ba0d119afc3eb2fd7d50 Mon Sep 17 00:00:00 2001
From: JS Deck <jsdeckerido@gmail.com>
Date: Sun, 7 Dec 2025 20:33:29 -0400
Subject: [PATCH 8/9] faudio/xaudio2: Partially rewrite asserts to error
 handling to avoid crash when audio device in use is disconnected.

---
 dlls/xaudio2_7/xaudio_dll.c             |  14 +-
 libs/faudio/src/FAudio.c                |   2 +-
 libs/faudio/src/FAudio_platform_win32.c | 655 +++++++++++++++++-------
 3 files changed, 480 insertions(+), 191 deletions(-)

diff --git a/dlls/xaudio2_7/xaudio_dll.c b/dlls/xaudio2_7/xaudio_dll.c
index 0cbb8187fa1..a8ee66ff61f 100644
--- a/dlls/xaudio2_7/xaudio_dll.c
+++ b/dlls/xaudio2_7/xaudio_dll.c
@@ -1748,6 +1748,7 @@ static HRESULT WINAPI IXAudio2Impl_CreateMasteringVoice(IXAudio2 *iface,
 {
     IXAudio2Impl *This = impl_from_IXAudio2(iface);
     FAudioEffectChain *chain;
+    HRESULT hr;
 
     TRACE("(%p)->(%p, %u, %u, 0x%x, %p)\n", This,
             ppMasteringVoice, inputChannels, inputSampleRate, flags, pEffectChain);
@@ -1777,21 +1778,26 @@ static HRESULT WINAPI IXAudio2Impl_CreateMasteringVoice(IXAudio2 *iface,
 #if XAUDIO2_VER >= 8
     TRACE("device id %s, category %#x\n", debugstr_w(deviceId), streamCategory);
 
-    FAudio_CreateMasteringVoice8(This->faudio, &This->mst.faudio_voice, inputChannels,
+    hr = FAudio_CreateMasteringVoice8(This->faudio, &This->mst.faudio_voice, inputChannels,
             inputSampleRate, flags, (uint16_t*)deviceId,
             This->mst.effect_chain, (FAudioStreamCategory)streamCategory);
 #else
     TRACE("device index %u\n", index);
 
-    FAudio_CreateMasteringVoice(This->faudio, &This->mst.faudio_voice, inputChannels,
+    hr = FAudio_CreateMasteringVoice(This->faudio, &This->mst.faudio_voice, inputChannels,
             inputSampleRate, flags, index, This->mst.effect_chain);
 #endif
 
-    This->mst.in_use = TRUE;
+    if (SUCCEEDED(hr))
+        This->mst.in_use = TRUE;
+    else {
+        free_effect_chain(This->mst.effect_chain);
+        *ppMasteringVoice = NULL;
+    }
 
     LeaveCriticalSection(&This->mst.lock);
 
-    return S_OK;
+    return hr;
 }
 
 static HRESULT WINAPI IXAudio2Impl_StartEngine(IXAudio2 *iface)
diff --git a/libs/faudio/src/FAudio.c b/libs/faudio/src/FAudio.c
index d07fb7aa5af..a011e89d89f 100644
--- a/libs/faudio/src/FAudio.c
+++ b/libs/faudio/src/FAudio.c
@@ -781,7 +781,7 @@ static uint32_t CreateMasteringVoiceImpl(
 	if (audio->platform == NULL)
 	{
 		FAudioVoice_DestroyVoice(*ppMasteringVoice);
-		*ppMasteringVoice = NULL;
+		audio->master = *ppMasteringVoice = NULL;
 
 		/* Not the best code, but it's probably true? */
 		return FAUDIO_E_DEVICE_INVALIDATED;
diff --git a/libs/faudio/src/FAudio_platform_win32.c b/libs/faudio/src/FAudio_platform_win32.c
index ec2df015088..3168cbfc50a 100644
--- a/libs/faudio/src/FAudio_platform_win32.c
+++ b/libs/faudio/src/FAudio_platform_win32.c
@@ -48,7 +48,7 @@ DEFINE_MEDIATYPE_GUID(MFAudioFormat_XMAudio2, FAUDIO_FORMAT_XMAUDIO2);
 
 static CRITICAL_SECTION faudio_cs = { NULL, -1, 0, 0, 0, 0 };
 static IMMDeviceEnumerator *device_enumerator;
-static HRESULT init_hr;
+static HRESULT init_hr = -1;
 
 struct FAudioWin32PlatformData
 {
@@ -167,35 +167,49 @@ static DWORD WINAPI FAudio_AudioClientThread(void *user)
 		&IID_IAudioRenderClient,
 		(void **)&render_client
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to get IAudioRenderClient service!");
+	if (FAILED(hr))
+		/* Failed to get IAudioRenderClient service! */
+		goto fail_free;
 
 	hr = IAudioClient_GetBufferSize(args->client, &frames);
-	FAudio_assert(!FAILED(hr) && "Failed to get IAudioClient buffer size!");
+	if (FAILED(hr))
+		/* Failed to get IAudioClient buffer size! */
+		goto fail_release;
 
 	hr = FAudio_FillAudioClientBuffer(args, render_client, frames, 0);
-	FAudio_assert(!FAILED(hr) && "Failed to initialize IAudioClient buffer!");
+	if (FAILED(hr))
+		/* Failed to initialize IAudioClient buffer! */
+		goto fail_release;
 
 	hr = IAudioClient_Start(args->client);
-	FAudio_assert(!FAILED(hr) && "Failed to start IAudioClient!");
+	if (FAILED(hr))
+		/* Failed to start IAudioClient! */
+		goto fail_release;
 
 	while (WaitForMultipleObjects(2, args->events, FALSE, INFINITE) == WAIT_OBJECT_0)
 	{
 		hr = IAudioClient_GetCurrentPadding(args->client, &padding);
 		if (hr == AUDCLNT_E_DEVICE_INVALIDATED)
-		{
 			/* Device was removed, just exit */
 			break;
-		}
-		FAudio_assert(!FAILED(hr) && "Failed to get IAudioClient current padding!");
+		if (FAILED(hr))
+			/* Failed to get IAudioClient current padding! */
+			goto fail_release;
 
 		hr = FAudio_FillAudioClientBuffer(args, render_client, frames, padding);
-		FAudio_assert(!FAILED(hr) && "Failed to fill IAudioClient buffer!");
+		if (FAILED(hr))
+			/* Failed to fill IAudioClient buffer! */
+			goto fail_release;
 	}
 
 	hr = IAudioClient_Stop(args->client);
-	FAudio_assert(!FAILED(hr) && "Failed to stop IAudioClient!");
+	if (FAILED(hr))
+		/* Failed to stop IAudioClient! */
+		goto fail_release;
 
+fail_release:
 	IAudioRenderClient_Release(render_client);
+fail_free:
 	FAudio_free(args);
 	return 0;
 }
@@ -413,10 +427,14 @@ void FAudio_PlatformInit(
 	*platformDevice = NULL;
 
 	args = FAudio_malloc(sizeof(*args));
-	FAudio_assert(!!args && "Failed to allocate FAudio thread args!");
+	if (!args)
+		/* Failed to allocate FAudio thread args! */
+		goto fail_release;
 
 	data = FAudio_malloc(sizeof(*data));
-	FAudio_assert(!!data && "Failed to allocate FAudio platform data!");
+	if (!data)
+		/* Failed to allocate FAudio platform data! */
+		goto fail_free_args;
 	FAudio_zero(data, sizeof(*data));
 
 	args->format.Format.wFormatTag = mixFormat->Format.wFormatTag;
@@ -439,22 +457,19 @@ void FAudio_PlatformInit(
 	}
 
 	audioEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
-	FAudio_assert(!!audioEvent && "Failed to create FAudio thread buffer event!");
+	if (!audioEvent)
+		/* Failed to create FAudio thread buffer event! */
+		goto fail_free_data;
 
 	data->stopEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
-	FAudio_assert(!!data->stopEvent && "Failed to create FAudio thread stop event!");
+	if (!data->stopEvent)
+		/* Failed to create FAudio thread stop event! */
+		goto fail_close_audio_evt;
 
 	hr = FAudio_OpenDevice(deviceIndex, deviceId, &device);
-	FAudio_assert(!FAILED(hr) && "Failed to get audio device!");
 	if (!device)
-	{
-		CloseHandle(data->stopEvent);
-		CloseHandle(audioEvent);
-		FAudio_free(data);
-		FAudio_free(args);
-		FAudio_PlatformRelease();
-		return;
-	}
+		/* Failed to get audio device! */
+		goto fail_close_stop_evt;
 
 	hr = IMMDevice_Activate(
 		device,
@@ -463,7 +478,9 @@ void FAudio_PlatformInit(
 		NULL,
 		(void **)&data->client
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to create audio client!");
+	if (FAILED(hr))
+		/* Failed to create audio client! */
+		goto fail_device;
 	IMMDevice_Release(device);
 
 	if (flags & FAUDIO_1024_QUANTUM) duration = 213333;
@@ -475,7 +492,9 @@ void FAudio_PlatformInit(
 		&args->format.Format,
 		&closest
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to find supported audio format!");
+	if (FAILED(hr))
+		/* Failed to find supported audio format! */
+		goto fail_audio;
 
 	if (closest)
 	{
@@ -493,10 +512,14 @@ void FAudio_PlatformInit(
 		&args->format.Format,
 		&GUID_NULL
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to initialize audio client!");
+	if (FAILED(hr))
+		/* Failed to initialize audio client! */
+		goto fail_audio;
 
 	hr = IAudioClient_SetEventHandle(data->client, audioEvent);
-	FAudio_assert(!FAILED(hr) && "Failed to set audio client event!");
+	if (FAILED(hr))
+		/* Failed to set audio client event! */
+		goto fail_audio;
 
 	mixFormat->Format.wFormatTag = args->format.Format.wFormatTag;
 	mixFormat->Format.nChannels = args->format.Format.nChannels;
@@ -529,11 +552,29 @@ void FAudio_PlatformInit(
 	else args->updateSize = args->format.Format.nSamplesPerSec / 100;
 
 	data->audioThread = CreateThread(NULL, 0, &FAudio_AudioClientThread, args, 0, NULL);
-	FAudio_assert(!!data->audioThread && "Failed to create audio client thread!");
+	if (!data->audioThread)
+		/* Failed to create audio client thread! */
+		goto fail_audio;
 
 	*updateSize = args->updateSize;
 	*platformDevice = data;
 	return;
+
+fail_audio:
+	IAudioClient_Release(data->client);
+fail_device:
+	IMMDevice_Release(device);
+fail_close_stop_evt:
+	CloseHandle(data->stopEvent);
+fail_close_audio_evt:
+	CloseHandle(audioEvent);
+fail_free_data:
+	FAudio_free(data);
+fail_free_args:
+	FAudio_free(args);
+fail_release:
+	FAudio_PlatformRelease();
+	return;
 }
 
 void FAudio_PlatformQuit(void* platformDevice)
@@ -556,8 +597,7 @@ void FAudio_PlatformAddRef()
 {
 	HRESULT hr;
 	EnterCriticalSection(&faudio_cs);
-	if (!device_enumerator)
-	{
+	if (!device_enumerator) {
 		init_hr = CoInitialize(NULL);
 		hr = CoCreateInstance(
 			&CLSID_MMDeviceEnumerator,
@@ -566,19 +606,29 @@ void FAudio_PlatformAddRef()
 			&IID_IMMDeviceEnumerator,
 			(void**)&device_enumerator
 		);
-		FAudio_assert(!FAILED(hr) && "CoCreateInstance failed!");
+		if (FAILED(hr)) {
+			/* CoCreateInstance failed! */
+			device_enumerator = NULL;
+			if (SUCCEEDED(init_hr)) {
+				CoUninitialize();
+				init_hr = -1;
+			}
+		}
 	}
-	else IMMDeviceEnumerator_AddRef(device_enumerator);
+	else
+		IMMDeviceEnumerator_AddRef(device_enumerator);
 	LeaveCriticalSection(&faudio_cs);
 }
 
 void FAudio_PlatformRelease()
 {
 	EnterCriticalSection(&faudio_cs);
-	if (!IMMDeviceEnumerator_Release(device_enumerator))
-	{
+	if (device_enumerator && !IMMDeviceEnumerator_Release(device_enumerator)) {
 		device_enumerator = NULL;
-		if (SUCCEEDED(init_hr)) CoUninitialize();
+		if (SUCCEEDED(init_hr)) {
+			CoUninitialize();
+			init_hr = -1;
+		}
 	}
 	LeaveCriticalSection(&faudio_cs);
 }
@@ -586,7 +636,7 @@ void FAudio_PlatformRelease()
 uint32_t FAudio_PlatformGetDeviceCount(void)
 {
 	IMMDeviceCollection *device_collection;
-	uint32_t count;
+	uint32_t count = 0;
 	HRESULT hr;
 
 	FAudio_PlatformAddRef();
@@ -598,21 +648,19 @@ uint32_t FAudio_PlatformGetDeviceCount(void)
 		&device_collection
 	);
 	if (FAILED(hr)) {
-		FAudio_PlatformRelease();
-		return 0;
+		goto fail_release;
 	}
 
 	hr = IMMDeviceCollection_GetCount(device_collection, &count);
 	if (FAILED(hr)) {
-		IMMDeviceCollection_Release(device_collection);
-		FAudio_PlatformRelease();
-		return 0;
+		count = 0;
+		goto fail_col_release;
 	}
 
+fail_col_release:
 	IMMDeviceCollection_Release(device_collection);
-
+fail_release:
 	FAudio_PlatformRelease();
-
 	return count;
 }
 
@@ -623,9 +671,9 @@ uint32_t FAudio_PlatformGetDeviceDetails(
 ) {
 	WAVEFORMATEX *format, *obtained;
 	WAVEFORMATEXTENSIBLE *ext;
-	IAudioClient *client;
+	IAudioClient *client = NULL;
 	IMMDevice *device = NULL;
-	IPropertyStore* properties;
+	IPropertyStore* properties = NULL;
 	PROPVARIANT deviceName;
 	uint32_t count = 0;
 	uint32_t ret = 0;
@@ -649,77 +697,82 @@ uint32_t FAudio_PlatformGetDeviceDetails(
 		);
 		if (FAILED(hr))
 		{
-			FAudio_PlatformRelease();
-			return FAUDIO_E_INVALID_CALL;
+			ret = FAUDIO_E_INVALID_CALL;
+			goto fail_release;
 		}
 		hr = IMMDevice_GetId(device, &default_guid);
 		if (FAILED(hr))
 		{
-			IMMDevice_Release(device);
-			FAudio_PlatformRelease();
-			return FAUDIO_E_INVALID_CALL;
+			ret = FAUDIO_E_INVALID_CALL;
+			default_guid = NULL;
+			goto fail_device;
 		}
 
 		/* Free the default device. */
 		IMMDevice_Release(device);
+		device = NULL;
 	}
 	else
 	{
 		count = FAudio_PlatformGetDeviceCount();
 		if (index >= count)
 		{
-			FAudio_PlatformRelease();
-			return FAUDIO_E_INVALID_CALL;
+			ret = FAUDIO_E_INVALID_CALL;
+			goto fail_release;
 		}
 	}
 
 	hr = FAudio_OpenDevice(index, deviceId, &device);
-	FAudio_assert(!FAILED(hr) && "Failed to get audio endpoint!");
-	if (!device)
+	if (FAILED(hr))
 	{
-		if (default_guid)
-			CoTaskMemFree(default_guid);
-		FAudio_PlatformRelease();
-		return FAUDIO_E_INVALID_CALL;
+		/* Failed to get audio endpoint! */
+		ret = FAUDIO_E_INVALID_CALL;
+		goto fail_defguid;
 	}
 
 	if (deviceId)
 	{
 		if (lstrcmpiW(default_guid, deviceId) == 0)
-		{
 			details->Role = FAudioGlobalDefaultDevice;
-		}
 		else
-		{
 			details->Role = FAudioNotDefaultDevice;
-		}
 
 		CoTaskMemFree(default_guid);
+		default_guid = NULL;
 	}
 	else
 	{
 		if (index == 0)
-		{
 			details->Role = FAudioGlobalDefaultDevice;
-		}
 		else
-		{
 			details->Role = FAudioNotDefaultDevice;
-		}
 	}
 
 	/* Set the Device Display Name */
 	hr = IMMDevice_OpenPropertyStore(device, STGM_READ, &properties);
-	FAudio_assert(!FAILED(hr) && "Failed to open device property store!");
+	if (FAILED(hr)) {
+		/* Failed to open device property store! */
+		ret = FAUDIO_E_INVALID_CALL;
+		goto fail_propstore;
+	}
 	hr = IPropertyStore_GetValue(properties, (PROPERTYKEY*)&DEVPKEY_Device_FriendlyName, &deviceName);
-	FAudio_assert(!FAILED(hr) && "Failed to get audio device friendly name!");
+	if (FAILED(hr)) {
+		/* Failed to get audio device friendly name! */
+		ret = FAUDIO_E_INVALID_CALL;
+		goto fail_propstore;
+	}
 	lstrcpynW((LPWSTR)details->DisplayName, deviceName.pwszVal, ARRAYSIZE(details->DisplayName) - 1);
 	PropVariantClear(&deviceName);
 	IPropertyStore_Release(properties);
+	properties = NULL;
 
 	/* Set the Device ID */
 	hr = IMMDevice_GetId(device, &str);
-	FAudio_assert(!FAILED(hr) && "Failed to get audio endpoint id!");
+	if (FAILED(hr)) {
+		/* Failed to get audio endpoint id! */
+		ret = FAUDIO_E_INVALID_CALL;
+		goto fail_device;
+	}
 	lstrcpynW((LPWSTR)details->DeviceID, str, ARRAYSIZE(details->DeviceID) - 1);
 	CoTaskMemFree(str);
 
@@ -730,10 +783,18 @@ uint32_t FAudio_PlatformGetDeviceDetails(
 		NULL,
 		(void **)&client
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to activate audio client!");
+	if (FAILED(hr)) {
+		/* Failed to activate audio client! */
+		ret = FAUDIO_E_INVALID_CALL;
+		goto fail_device;
+	}
 
 	hr = IAudioClient_GetMixFormat(client, &format);
-	FAudio_assert(!FAILED(hr) && "Failed to get audio client mix format!");
+	if (FAILED(hr)) {
+		/* Failed to get audio client mix format! */
+		ret = FAUDIO_E_INVALID_CALL;
+		goto fail_client;
+	}
 
 	if (format->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
 	{
@@ -747,9 +808,7 @@ uint32_t FAudio_PlatformGetDeviceDetails(
 
 		hr = IAudioClient_IsFormatSupported(client, AUDCLNT_SHAREMODE_SHARED, format, &obtained);
 		if (FAILED(hr))
-		{
 			ext->SubFormat = sub;
-		}
 		else if (obtained)
 		{
 			CoTaskMemFree(format);
@@ -777,18 +836,24 @@ uint32_t FAudio_PlatformGetDeviceDetails(
 		);
 	}
 	else
-	{
 		details->OutputFormat.dwChannelMask = GetMask(format->nChannels);
-	}
 
 	CoTaskMemFree(format);
 
-	IAudioClient_Release(client);
-
-	IMMDevice_Release(device);
-
+fail_client:
+	if (client)
+		IAudioClient_Release(client);
+fail_propstore:
+	if (properties)
+		IPropertyStore_Release(properties);
+fail_device:
+	if (device)
+		IMMDevice_Release(device);
+fail_defguid:
+	if (default_guid)
+		CoTaskMemFree(default_guid);
+fail_release:
 	FAudio_PlatformRelease();
-
 	return ret;
 }
 
@@ -1062,19 +1127,21 @@ static void XNA_SongSubmitBuffer(FAudioVoiceCallback *callback, void *pBufferCon
 		NULL,
 		&sample
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to read audio sample!");
+	if (FAILED(hr))
+		/* Failed to read audio sample! */
+		goto fail_exit;
 
 	if (flags & MF_SOURCE_READERF_ENDOFSTREAM)
-	{
 		buffer.Flags = FAUDIO_END_OF_STREAM;
-	}
 	else
 	{
 		hr = IMFSample_ConvertToContiguousBuffer(
 			sample,
 			&media_buffer
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to get sample buffer!");
+		if (FAILED(hr))
+			/* Failed to get sample buffer! */
+			goto fail_release;
 
 		hr = IMFMediaBuffer_Lock(
 			media_buffer,
@@ -1082,20 +1149,31 @@ static void XNA_SongSubmitBuffer(FAudioVoiceCallback *callback, void *pBufferCon
 			NULL,
 			&buffer_size
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to lock buffer bytes!");
+		if (FAILED(hr))
+			/* Failed to lock buffer bytes! */
+			goto fail_media_release;
 
 		if (songBufferSize < buffer_size)
 		{
-			songBufferSize = buffer_size;
 			songBuffer = FAudio_realloc(songBuffer, songBufferSize);
-			FAudio_assert(songBuffer != NULL && "Failed to allocate song buffer!");
+			if (!songBuffer) {
+				/* Failed to allocate song buffer! */
+				songBufferSize = 0;
+				goto fail_media_unlock;
+			}
+			songBufferSize = buffer_size;
 		}
 		FAudio_memcpy(songBuffer, buffer_ptr, buffer_size);
 
+fail_media_unlock:
 		hr = IMFMediaBuffer_Unlock(media_buffer);
-		FAudio_assert(!FAILED(hr) && "Failed to unlock buffer bytes!");
+		if (FAILED(hr))
+			/* Failed to unlock buffer bytes! */
+			goto fail_media_release;
 
+fail_media_release:
 		IMFMediaBuffer_Release(media_buffer);
+fail_release:
 		IMFSample_Release(sample);
 	}
 
@@ -1116,12 +1194,13 @@ static void XNA_SongSubmitBuffer(FAudioVoiceCallback *callback, void *pBufferCon
 		);
 	}
 
+fail_exit:
 	LOG_FUNC_EXIT(songAudio);
 }
 
 static void XNA_SongKill()
 {
-	if (songVoice != NULL)
+	if (songVoice)
 	{
 		FAudioSourceVoice_Stop(songVoice, 0, 0);
 		FAudioVoice_DestroyVoice(songVoice);
@@ -1132,19 +1211,22 @@ static void XNA_SongKill()
 		IMFSourceReader_Release(activeSong);
 		activeSong = NULL;
 	}
-	FAudio_free(songBuffer);
-	songBuffer = NULL;
-	songBufferSize = 0;
+	if (songBuffer) {
+		FAudio_free(songBuffer);
+		songBuffer = NULL;
+		songBufferSize = 0;
+	}
 }
 
 /* "Public" API */
 
+static HRESULT mf_init_hr = -1;
 FAUDIOAPI void XNA_SongInit()
 {
-	HRESULT hr;
-
-	hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
-	FAudio_assert(!FAILED(hr) && "Failed to initialize Media Foundation!");
+	mf_init_hr = MFStartup(MF_VERSION, MFSTARTUP_FULL);
+	if (FAILED(mf_init_hr))
+		/* Failed to initialize Media Foundation! */
+		return;
 
 	FAudioCreate(&songAudio, 0, FAUDIO_DEFAULT_PROCESSOR);
 	FAudio_CreateMasteringVoice(
@@ -1161,9 +1243,18 @@ FAUDIOAPI void XNA_SongInit()
 FAUDIOAPI void XNA_SongQuit()
 {
 	XNA_SongKill();
-	FAudioVoice_DestroyVoice(songMaster);
-	FAudio_Release(songAudio);
-        MFShutdown();
+	if (songMaster) {
+		FAudioVoice_DestroyVoice(songMaster);
+		songMaster = NULL;
+	}
+	if (songAudio) {
+		FAudio_Release(songAudio);
+		songAudio = NULL;
+	}
+	if (SUCCEEDED(mf_init_hr)) {
+		MFShutdown();
+		mf_init_hr = -1;
+	}
 }
 
 FAUDIOAPI float XNA_PlaySong(const char *name)
@@ -1183,63 +1274,95 @@ FAUDIOAPI float XNA_PlaySong(const char *name)
 	MultiByteToWideChar(CP_UTF8, 0, name, -1, filename_w, MAX_PATH);
 
 	hr = MFCreateAttributes(&attributes, 1);
-	FAudio_assert(!FAILED(hr) && "Failed to create attributes!");
+	if (FAILED(hr))
+		/* Failed to create attributes! */
+		goto fail_exit;
+
 	hr = MFCreateSourceReaderFromURL(
 		filename_w,
 		attributes,
 		&activeSong
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to create source reader!");
+	if (FAILED(hr))
+		/* Failed to create source reader! */
+		goto fail_attributes;
+
 	IMFAttributes_Release(attributes);
+	attributes = NULL;
 
 	hr = MFCreateMediaType(&media_type);
-	FAudio_assert(!FAILED(hr) && "Failed to create media type!");
+	if (FAILED(hr))
+		/* Failed to create media type! */
+		goto fail_exit;
 	hr = IMFMediaType_SetGUID(
 		media_type,
 		&MF_MT_MAJOR_TYPE,
 		&MFMediaType_Audio
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to set major type!");
+	if (FAILED(hr))
+		/* Failed to set major type! */
+		goto fail_media_type;
+
 	hr = IMFMediaType_SetGUID(
 		media_type,
 		&MF_MT_SUBTYPE,
 		&MFAudioFormat_Float
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to set sub type!");
+	if (FAILED(hr))
+		/* Failed to set sub type! */
+		goto fail_media_type;
+
 	hr = IMFSourceReader_SetCurrentMediaType(
 		activeSong,
 		MF_SOURCE_READER_FIRST_AUDIO_STREAM,
 		NULL,
 		media_type
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to set source media type!");
+	if (FAILED(hr))
+		/* Failed to set source media type! */
+		goto fail_media_type;
+
 	hr = IMFSourceReader_SetStreamSelection(
 		activeSong,
 		MF_SOURCE_READER_FIRST_AUDIO_STREAM,
 		TRUE
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to select source stream!");
+	if (FAILED(hr))
+		/* Failed to select source stream! */
+		goto fail_media_type;
+
 	IMFMediaType_Release(media_type);
+	media_type = NULL;
 
 	hr = IMFSourceReader_GetCurrentMediaType(
 		activeSong,
 		MF_SOURCE_READER_FIRST_AUDIO_STREAM,
 		&media_type
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to get current media type!");
+	if (FAILED(hr))
+		/* Failed to get current media type! */
+		goto fail_exit;
+
 	hr = IMFMediaType_GetUINT32(
 		media_type,
 		&MF_MT_AUDIO_NUM_CHANNELS,
 		&channels
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to get channel count!");
+	if (FAILED(hr))
+		/* Failed to get channel count! */
+		goto fail_media_type;
+
 	hr = IMFMediaType_GetUINT32(
 		media_type,
 		&MF_MT_AUDIO_SAMPLES_PER_SECOND,
 		&samplerate
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to get sample rate!");
+	if (FAILED(hr))
+		/* Failed to get sample rate! */
+		goto fail_media_type;
+
 	IMFMediaType_Release(media_type);
+	media_type = NULL;
 
 	hr = IMFSourceReader_GetPresentationAttribute(
 		activeSong,
@@ -1247,10 +1370,17 @@ FAUDIOAPI float XNA_PlaySong(const char *name)
 		&MF_PD_DURATION,
 		&var
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to get song duration!");
-        hr = PropVariantToInt64(&var, &duration);
-	FAudio_assert(!FAILED(hr) && "Failed to get song duration!");
-        PropVariantClear(&var);
+	if (FAILED(hr))
+		/* Failed to get song duration! */
+		goto fail_exit;
+
+	hr = PropVariantToInt64(&var, &duration);
+	if (FAILED(hr)) {
+		/* Failed to get song duration! */
+		PropVariantClear(&var);
+		goto fail_exit;
+	}
+    PropVariantClear(&var);
 
 	activeSongFormat.wFormatTag = FAUDIO_FORMAT_IEEE_FLOAT;
 	activeSongFormat.nChannels = channels;
@@ -1273,11 +1403,21 @@ FAUDIOAPI float XNA_PlaySong(const char *name)
 		NULL,
 		NULL
 	);
-	FAudioVoice_SetVolume(songVoice, songVolume, 0);
-	XNA_SongSubmitBuffer(NULL, NULL);
+	if (songVoice) {
+		FAudioVoice_SetVolume(songVoice, songVolume, 0);
+		XNA_SongSubmitBuffer(NULL, NULL);
 
-	/* Finally. */
-	FAudioSourceVoice_Start(songVoice, 0, 0);
+		/* Finally. */
+		FAudioSourceVoice_Start(songVoice, 0, 0);
+	}
+
+fail_media_type:
+	if (media_type)
+		IMFMediaType_Release(media_type);
+fail_attributes:
+	if (attributes)
+		IMFAttributes_Release(attributes);
+fail_exit:
 	LOG_FUNC_EXIT(songAudio);
 	return duration / 10000000.;
 }
@@ -1363,7 +1503,7 @@ static HRESULT FAudio_WMAMF_ProcessInput(
 	FAudioBuffer *buffer
 ) {
 	struct FAudioWMADEC *impl = voice->src.wmadec;
-	IMFMediaBuffer *media_buffer;
+	IMFMediaBuffer *media_buffer = NULL;
 	IMFSample *sample;
 	DWORD copy_size;
 	BYTE *copy_buf;
@@ -1374,28 +1514,44 @@ static HRESULT FAudio_WMAMF_ProcessInput(
 	LOG_INFO(voice->audio, "pushing %lx bytes at %Ix", copy_size, impl->input_pos);
 
 	hr = MFCreateSample(&sample);
-	FAudio_assert(!FAILED(hr) && "Failed to create sample!");
+	if (FAILED(hr))
+		/* Failed to create sample! */
+		goto fail;
 	hr = MFCreateMemoryBuffer(copy_size, &media_buffer);
-	FAudio_assert(!FAILED(hr) && "Failed to create buffer!");
+	if (FAILED(hr))
+		/* Failed to create buffer! */
+		goto fail_sample;
 	hr = IMFMediaBuffer_SetCurrentLength(media_buffer, copy_size);
-	FAudio_assert(!FAILED(hr) && "Failed to set buffer length!");
+	if (FAILED(hr))
+		/* Failed to set buffer length! */
+		goto fail_mem;
 	hr = IMFMediaBuffer_Lock(
 		media_buffer,
 		&copy_buf,
 		NULL,
 		&copy_size
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to lock buffer bytes!");
+	if (FAILED(hr))
+		/* Failed to lock buffer bytes! */
+		goto fail_mem;
 	FAudio_memcpy(copy_buf, buffer->pAudioData + impl->input_pos, copy_size);
 	hr = IMFMediaBuffer_Unlock(media_buffer);
-	FAudio_assert(!FAILED(hr) && "Failed to unlock buffer bytes!");
+	if (FAILED(hr))
+		/* Failed to unlock buffer bytes! */
+		goto fail_mem;
 
 	hr = IMFSample_AddBuffer(sample, media_buffer);
-	FAudio_assert(!FAILED(hr) && "Failed to buffer to sample!");
+	if (FAILED(hr))
+		/* Failed to buffer to sample! */
+		goto fail_mem;
+
 	IMFMediaBuffer_Release(media_buffer);
+	media_buffer = NULL;
 
 	hr = IMFTransform_ProcessInput(impl->decoder, 0, sample, 0);
 	IMFSample_Release(sample);
+	sample = NULL;
+
 	if (hr == MF_E_NOTACCEPTING) return S_OK;
 	if (FAILED(hr))
 	{
@@ -1404,7 +1560,16 @@ static HRESULT FAudio_WMAMF_ProcessInput(
 	}
 
 	impl->input_pos += copy_size;
-	return S_OK;
+	hr = S_OK;
+
+fail_mem:
+	if (media_buffer)
+		IMFMediaBuffer_Release(media_buffer);
+fail_sample:
+	if (sample)
+		IMFSample_Release(sample);
+fail:
+	return hr;
 };
 
 static HRESULT FAudio_WMAMF_ProcessOutput(
@@ -1413,7 +1578,7 @@ static HRESULT FAudio_WMAMF_ProcessOutput(
 ) {
 	struct FAudioWMADEC *impl = voice->src.wmadec;
 	MFT_OUTPUT_DATA_BUFFER output;
-	IMFMediaBuffer *media_buffer;
+	IMFMediaBuffer *media_buffer = NULL;
 	DWORD status, copy_size;
 	BYTE *copy_buf;
 	HRESULT hr;
@@ -1436,14 +1601,18 @@ static HRESULT FAudio_WMAMF_ProcessOutput(
 			output.pSample,
 			&media_buffer
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to get sample buffer!");
+		if (FAILED(hr))
+			/* Failed to get sample buffer! */
+			goto fail_mem;
 		hr = IMFMediaBuffer_Lock(
 			media_buffer,
 			&copy_buf,
 			NULL,
 			&copy_size
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to lock buffer bytes!");
+		if (FAILED(hr))
+			/* Failed to lock buffer bytes! */
+			goto fail_mem;
 		if (impl->output_pos + copy_size > impl->output_size)
 		{
 			impl->output_size = max(
@@ -1454,19 +1623,30 @@ static HRESULT FAudio_WMAMF_ProcessOutput(
 				impl->output_buf,
 				impl->output_size
 			);
-			FAudio_assert(impl->output_buf && "Failed to resize output buffer!");
+			if (!impl->output_buf) {
+				/* Failed to resize output buffer! */
+				impl->output_size = 0;
+				goto fail_mem;
+			}
 		}
 		FAudio_memcpy(impl->output_buf + impl->output_pos, copy_buf, copy_size);
 		impl->output_pos += copy_size;
 		LOG_INFO(voice->audio, "pulled %lx bytes at %Ix", copy_size, impl->output_pos);
 		hr = IMFMediaBuffer_Unlock(media_buffer);
-		FAudio_assert(!FAILED(hr) && "Failed to unlock buffer bytes!");
+		if (FAILED(hr))
+			/* Failed to unlock buffer bytes! */
+			goto fail_mem;
 
 		IMFMediaBuffer_Release(media_buffer);
-		if (!impl->output_sample) IMFSample_Release(output.pSample);
+		media_buffer = NULL;
+		if (!impl->output_sample)
+			IMFSample_Release(output.pSample);
 	}
 
-	return S_OK;
+fail_mem:
+	if (media_buffer)
+		IMFMediaBuffer_Release(media_buffer);
+	return hr;
 };
 
 static void FAudio_INTERNAL_DecodeWMAMF(
@@ -1512,7 +1692,11 @@ static void FAudio_INTERNAL_DecodeWMAMF(
 			impl->output_buf,
 			impl->output_size
 		);
-		FAudio_assert(impl->output_buf && "Failed to allocate output buffer!");
+		if (!impl->output_buf) {
+			/* Failed to allocate output buffer! */
+			impl->output_size = 0;
+			goto fail;
+		}
 
 		LOG_INFO(voice->audio, "sending BOS to %p", impl->decoder);
 		hr = IMFTransform_ProcessMessage(
@@ -1520,7 +1704,10 @@ static void FAudio_INTERNAL_DecodeWMAMF(
 			MFT_MESSAGE_NOTIFY_START_OF_STREAM,
 			0
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to notify decoder stream start!");
+		if (FAILED(hr)) {
+			/* Failed to notify decoder stream start! */
+			goto fail;
+		}
 		FAudio_WMAMF_ProcessInput(voice, buffer);
 	}
 
@@ -1530,11 +1717,11 @@ static void FAudio_INTERNAL_DecodeWMAMF(
 	while (impl->output_pos < samples_pos + samples_size)
 	{
 		hr = FAudio_WMAMF_ProcessOutput(voice, buffer);
-		if (FAILED(hr)) goto error;
+		if (FAILED(hr)) goto fail;
 		if (hr == S_OK) continue;
 
 		hr  = FAudio_WMAMF_ProcessInput(voice, buffer);
-		if (FAILED(hr)) goto error;
+		if (FAILED(hr)) goto fail;
 		if (hr == S_OK) continue;
 
 		if (!impl->input_size) break;
@@ -1545,7 +1732,9 @@ static void FAudio_INTERNAL_DecodeWMAMF(
 			MFT_MESSAGE_NOTIFY_END_OF_STREAM,
 			0
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to send EOS!");
+		if (FAILED(hr))
+			/* Failed to send EOS! */
+			goto fail;
 		impl->input_size = 0;
 	}
 
@@ -1567,7 +1756,7 @@ static void FAudio_INTERNAL_DecodeWMAMF(
 	LOG_FUNC_EXIT(voice->audio)
 	return;
 
-error:
+fail:
 	FAudio_zero(decodeCache, samples * voice->src.format->nChannels * sizeof(float));
 	LOG_FUNC_EXIT(voice->audio)
 }
@@ -1579,9 +1768,9 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 	const FAudioWaveFormatExtensible *wfx = (FAudioWaveFormatExtensible *)voice->src.format;
 	struct FAudioWMADEC *impl;
 	MFT_OUTPUT_STREAM_INFO info = {0};
-	IMFMediaBuffer *media_buffer;
-	IMFMediaType *media_type;
-	IMFTransform *decoder;
+	IMFMediaBuffer *media_buffer = NULL;
+	IMFMediaType *media_type = NULL;
+	IMFTransform *decoder = NULL;
 	HRESULT hr;
 	UINT32 i, value;
 	GUID guid;
@@ -1600,18 +1789,22 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 	);
 	if (FAILED(hr))
 	{
-		voice->audio->pFree(impl->output_buf);
+		voice->audio->pFree(impl);
 		return -2;
 	}
 
 	hr = MFCreateMediaType(&media_type);
-	FAudio_assert(!FAILED(hr) && "Failed create media type!");
+	if (FAILED(hr))
+		/* Failed to create media type! */
+		goto fail_dec;
 	hr = IMFMediaType_SetGUID(
 		media_type,
 		&MF_MT_MAJOR_TYPE,
 		&MFMediaType_Audio
 	);
-	FAudio_assert(!FAILED(hr) && "Failed set media major type!");
+	if (FAILED(hr))
+		/* Failed to set media major type! */
+		goto fail_dec_type;
 
 	switch (type)
 	{
@@ -1622,46 +1815,58 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 			(void *)fake_codec_data,
 			sizeof(fake_codec_data)
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set codec private data!");
+		if (FAILED(hr))
+			/* Failed set codec private data! */
+			goto fail_dec_type;
 		hr = IMFMediaType_SetGUID(
 			media_type,
 			&MF_MT_SUBTYPE,
 			&MFAudioFormat_WMAudioV8
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set media sub type!");
+		if (FAILED(hr))
+			/* Failed set media sub type! */
+			goto fail_dec_type;
 		hr = IMFMediaType_SetUINT32(
 			media_type,
 			&MF_MT_AUDIO_BLOCK_ALIGNMENT,
 			wfx->Format.nBlockAlign
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set input block align!");
+		if (FAILED(hr))
+			/* Failed set input block align! */
+			goto fail_dec_type;
 		break;
 	case FAUDIO_FORMAT_WMAUDIO3:
-                *(uint16_t *)fake_codec_data_wma3  = voice->src.format->wBitsPerSample;
-                for (i = 0; i < voice->src.format->nChannels; i++)
-                {
-                    fake_codec_data_wma3[2] <<= 1;
-                    fake_codec_data_wma3[2] |= 1;
-                }
+		*(uint16_t *)fake_codec_data_wma3  = voice->src.format->wBitsPerSample;
+		for (i = 0; i < voice->src.format->nChannels; i++)
+		{
+			fake_codec_data_wma3[2] <<= 1;
+			fake_codec_data_wma3[2] |= 1;
+		}
 		hr = IMFMediaType_SetBlob(
 			media_type,
 			&MF_MT_USER_DATA,
 			(void *)fake_codec_data_wma3,
 			sizeof(fake_codec_data_wma3)
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set codec private data!");
+		if (FAILED(hr))
+			/* Failed set codec private data! */
+			goto fail_dec_type;
 		hr = IMFMediaType_SetGUID(
 			media_type,
 			&MF_MT_SUBTYPE,
 			&MFAudioFormat_WMAudioV9
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set media sub type!");
+		if (FAILED(hr))
+			/* Failed set media sub type! */
+			goto fail_dec_type;
 		hr = IMFMediaType_SetUINT32(
 			media_type,
 			&MF_MT_AUDIO_BLOCK_ALIGNMENT,
 			wfx->Format.nBlockAlign
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set input block align!");
+		if (FAILED(hr))
+			/* Failed set input block align! */
+			goto fail_dec_type;
 		break;
 	case FAUDIO_FORMAT_WMAUDIO_LOSSLESS:
 		hr = IMFMediaType_SetBlob(
@@ -1670,19 +1875,25 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 			(void *)&wfx->Samples,
 			wfx->Format.cbSize
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set codec private data!");
+		if (FAILED(hr))
+			/* Failed set codec private data! */
+			goto fail_dec_type;
 		hr = IMFMediaType_SetGUID(
 			media_type,
 			&MF_MT_SUBTYPE,
 			&MFAudioFormat_WMAudio_Lossless
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set media sub type!");
+		if (FAILED(hr))
+			/* Failed set media sub type! */
+			goto fail_dec_type;
 		hr = IMFMediaType_SetUINT32(
 			media_type,
 			&MF_MT_AUDIO_BLOCK_ALIGNMENT,
 			wfx->Format.nBlockAlign
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set input block align!");
+		if (FAILED(hr))
+			/* Failed set input block align! */
+			goto fail_dec_type;
 		break;
 	case FAUDIO_FORMAT_XMAUDIO2:
 	{
@@ -1693,24 +1904,30 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 			(void *)&wfx->Samples,
 			wfx->Format.cbSize
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set codec private data!");
+		if (FAILED(hr))
+			/* Failed set codec private data! */
+			goto fail_dec_type;
 		hr = IMFMediaType_SetGUID(
 			media_type,
 			&MF_MT_SUBTYPE,
 			&MFAudioFormat_XMAudio2
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set media sub type!");
+		if (FAILED(hr))
+			/* Failed set media sub type! */
+			goto fail_dec_type;
 		hr = IMFMediaType_SetUINT32(
 			media_type,
 			&MF_MT_AUDIO_BLOCK_ALIGNMENT,
 			xwf->dwBytesPerBlock
 		);
-		FAudio_assert(!FAILED(hr) && "Failed set input block align!");
+		if (FAILED(hr))
+			/* Failed set input block align! */
+			goto fail_dec_type;
 		break;
 	}
 	default:
-		FAudio_assert(0 && "Unsupported type!");
-		break;
+		/* Unsupported type! */
+		goto fail_dec_type;
 	}
 
 	hr = IMFMediaType_SetUINT32(
@@ -1718,25 +1935,33 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 		&MF_MT_AUDIO_BITS_PER_SAMPLE,
 		wfx->Format.wBitsPerSample
 	);
-	FAudio_assert(!FAILED(hr) && "Failed set input bits per sample!");
+	if (FAILED(hr))
+		/* Failed set input bits per sample! */
+		goto fail_dec_type;
 	hr = IMFMediaType_SetUINT32(
 		media_type,
 		&MF_MT_AUDIO_AVG_BYTES_PER_SECOND,
 		wfx->Format.nAvgBytesPerSec
 	);
-	FAudio_assert(!FAILED(hr) && "Failed set input bytes per sample!");
+	if (FAILED(hr))
+		/* Failed set input bytes per sample! */
+		goto fail_dec_type;
 	hr = IMFMediaType_SetUINT32(
 		media_type,
 		&MF_MT_AUDIO_NUM_CHANNELS,
 		wfx->Format.nChannels
 	);
-	FAudio_assert(!FAILED(hr) && "Failed set input channel count!");
+	if (FAILED(hr))
+		/* Failed set input channel count! */
+		goto fail_dec_type;
 	hr = IMFMediaType_SetUINT32(
 		media_type,
 		&MF_MT_AUDIO_SAMPLES_PER_SECOND,
 		wfx->Format.nSamplesPerSec
 	);
-	FAudio_assert(!FAILED(hr) && "Failed set input sample rate!");
+	if (FAILED(hr))
+		/* Failed set input sample rate! */
+		goto fail_dec_type;
 
 	hr = IMFTransform_SetInputType(
 		decoder,
@@ -1744,8 +1969,11 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 		media_type,
 		0
 	);
-	FAudio_assert(!FAILED(hr) && "Failed set decoder input type!");
+	if (FAILED(hr))
+		/* Failed set decoder input type! */
+		goto fail_dec_type;
 	IMFMediaType_Release(media_type);
+	media_type = NULL;
 
 	i = 0;
 	while (SUCCEEDED(hr))
@@ -1756,14 +1984,18 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 			i++,
 			&media_type
 		);
-		FAudio_assert(!FAILED(hr) && "Failed get output media type!");
+		if (FAILED(hr))
+			/* Failed get output media type! */
+			goto fail_dec_type;
 
 		hr = IMFMediaType_GetGUID(
 			media_type,
 			&MF_MT_MAJOR_TYPE,
 			&guid
 		);
-		FAudio_assert(!FAILED(hr) && "Failed get media major type!");
+		if (FAILED(hr))
+			/* Failed get media major type! */
+			goto fail_dec_type;
 		if (!IsEqualGUID(&MFMediaType_Audio, &guid)) goto next;
 
 		hr = IMFMediaType_GetGUID(
@@ -1771,7 +2003,9 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 			&MF_MT_SUBTYPE,
 			&guid
 		);
-		FAudio_assert(!FAILED(hr) && "Failed get media major type!");
+		if (FAILED(hr))
+			/* Failed get media sub type! */
+			goto fail_dec_type;
 		if (!IsEqualGUID(&MFAudioFormat_Float, &guid)) goto next;
 
 		hr = IMFMediaType_GetUINT32(
@@ -1788,7 +2022,9 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 				value
 			);
 		}
-		FAudio_assert(!FAILED(hr) && "Failed get bits per sample!");
+		if (FAILED(hr))
+			/* Failed get bits per sample! */
+			goto fail_dec_type;
 		if (value != 32) goto next;
 
 		hr = IMFMediaType_GetUINT32(
@@ -1805,7 +2041,9 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 				value
 			);
 		}
-		FAudio_assert(!FAILED(hr) && "Failed get channel count!");
+		if (FAILED(hr))
+			/* Failed get channel count! */
+			goto fail_dec_type;
 		if (value != wfx->Format.nChannels) goto next;
 
 		hr = IMFMediaType_GetUINT32(
@@ -1822,7 +2060,9 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 				value
 			);
 		}
-		FAudio_assert(!FAILED(hr) && "Failed get sample rate!");
+		if (FAILED(hr))
+			/* Failed get sample rate! */
+			goto fail_dec_type;
 		if (value != wfx->Format.nSamplesPerSec) goto next;
 
 		hr = IMFMediaType_GetUINT32(
@@ -1839,30 +2079,50 @@ uint32_t FAudio_WMADEC_init(FAudioSourceVoice *voice, uint32_t type)
 				value
 			);
 		}
-		FAudio_assert(!FAILED(hr) && "Failed get block align!");
+		if (FAILED(hr))
+			/* Failed get block align! */
+			goto fail_dec_type;
+
 		if (value == wfx->Format.nChannels * sizeof(float)) break;
 
 next:
 		IMFMediaType_Release(media_type);
+		media_type = NULL;
 	}
-	FAudio_assert(!FAILED(hr) && "Failed to find output media type!");
+
+	if (FAILED(hr))
+		/* Failed to find output media type! */
+		goto fail_dec_type;
+
 	hr = IMFTransform_SetOutputType(decoder, 0, media_type, 0);
-	FAudio_assert(!FAILED(hr) && "Failed set decoder output type!");
+	if (FAILED(hr))
+		/* Failed to set decoder output type! */
+		goto fail_dec_type;
 	IMFMediaType_Release(media_type);
+	media_type = NULL;
 
 	hr = IMFTransform_GetOutputStreamInfo(decoder, 0, &info);
-	FAudio_assert(!FAILED(hr) && "Failed to get output stream info!");
+	if (FAILED(hr))
+		/* Failed to get output stream info! */
+		goto fail_dec_type;
 
 	impl->decoder = decoder;
 	if (!(info.dwFlags & MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES))
 	{
 		hr = MFCreateSample(&impl->output_sample);
-		FAudio_assert(!FAILED(hr) && "Failed to create sample!");
+		if (FAILED(hr))
+			/* Failed to create sample! */
+			goto fail_dec;
 		hr = MFCreateMemoryBuffer(info.cbSize, &media_buffer);
-		FAudio_assert(!FAILED(hr) && "Failed to create buffer!");
+		if (FAILED(hr))
+			/* Failed to create buffer! */
+			goto fail_dec_samp;
 		hr = IMFSample_AddBuffer(impl->output_sample, media_buffer);
-		FAudio_assert(!FAILED(hr) && "Failed to buffer to sample!");
+		if (FAILED(hr))
+			/* Failed to buffer to sample! */
+			goto fail_dec_mem;
 		IMFMediaBuffer_Release(media_buffer);
+		media_buffer = NULL;
 	}
 
 	hr = IMFTransform_ProcessMessage(
@@ -1870,13 +2130,30 @@ next:
 		MFT_MESSAGE_NOTIFY_BEGIN_STREAMING,
 		0
 	);
-	FAudio_assert(!FAILED(hr) && "Failed to start decoder stream!");
+	if (FAILED(hr))
+		/* Failed to start decoder stream! */
+		goto fail_dec_samp;
 
 	voice->src.wmadec = impl;
 	voice->src.decode = FAudio_INTERNAL_DecodeWMAMF;
 
 	LOG_FUNC_EXIT(voice->audio);
 	return 0;
+
+fail_dec_mem:
+	if (media_buffer)
+		IMFMediaBuffer_Release(media_buffer);
+fail_dec_type:
+	if (media_type)
+		IMFMediaType_Release(media_type);
+fail_dec_samp:
+	if (impl->output_sample)
+		IMFSample_Release(impl->output_sample);
+fail_dec:
+	if (decoder)
+		IMFTransform_Release(decoder);
+	voice->audio->pFree(impl);
+	return -1;
 }
 
 void FAudio_WMADEC_free(FAudioSourceVoice *voice)
@@ -1896,7 +2173,9 @@ void FAudio_WMADEC_free(FAudioSourceVoice *voice)
 			MFT_MESSAGE_NOTIFY_END_OF_STREAM,
 			0
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to send EOS!");
+		if (FAILED(hr))
+			/* Failed to send EOS! */
+		{}
 		impl->input_size = 0;
 	}
 	if (impl->output_pos)
@@ -1907,7 +2186,9 @@ void FAudio_WMADEC_free(FAudioSourceVoice *voice)
 			MFT_MESSAGE_COMMAND_DRAIN,
 			0
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to send DRAIN!");
+		if (FAILED(hr))
+			/* Failed to send DRAIN! */
+		{}
 		impl->output_pos = 0;
 	}
 
@@ -1938,7 +2219,9 @@ void FAudio_WMADEC_end_buffer(FAudioSourceVoice *voice)
 			MFT_MESSAGE_NOTIFY_END_OF_STREAM,
 			0
 		);
-		FAudio_assert(!FAILED(hr) && "Failed to send EOS!");
+		if (FAILED(hr))
+			/* Failed to send EOS! */
+		{}
 		impl->input_size = 0;
 	}
 	impl->output_pos = 0;
-- 
2.52.0

