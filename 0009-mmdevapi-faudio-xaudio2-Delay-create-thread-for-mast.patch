From bef844d57c85205c8b46b3d75a9ad1e03801ad6f Mon Sep 17 00:00:00 2001
From: JS Deck <jsdeckerido@gmail.com>
Date: Wed, 10 Dec 2025 23:09:50 -0400
Subject: [PATCH 9/9] mmdevapi/faudio/xaudio2: Delay create thread for
 mastering audio; delay kernelbase resolve; get default audio endpoint
 directly.

---
 dlls/mmdevapi/devenum.c                 |   9 +-
 libs/faudio/src/FAudio.c                |  46 ++++-
 libs/faudio/src/FAudio_internal.h       |   4 +
 libs/faudio/src/FAudio_platform_win32.c | 217 ++++++++++++++++--------
 4 files changed, 201 insertions(+), 75 deletions(-)

diff --git a/dlls/mmdevapi/devenum.c b/dlls/mmdevapi/devenum.c
index 6df43ca93ee..4949670fa6e 100644
--- a/dlls/mmdevapi/devenum.c
+++ b/dlls/mmdevapi/devenum.c
@@ -1397,6 +1397,9 @@ static HRESULT MMDevCol_Create(IMMDeviceCollection **ppv, EDataFlow flow, DWORD
     }
     LeaveCriticalSection(&device_list_cs);
 
+    /* Delay create thread as much as possible. */
+    create_update_thread();
+
     return S_OK;
 }
 
@@ -1520,9 +1523,6 @@ static HRESULT WINAPI MMDevEnum_QueryInterface(IMMDeviceEnumerator *iface, REFII
     if (!*ppv)
         return E_NOINTERFACE;
     IUnknown_AddRef((IUnknown*)*ppv);
-
-    create_update_thread();
-
     return S_OK;
 }
 
@@ -1852,6 +1852,9 @@ static HRESULT WINAPI MMDevEnum_RegisterEndpointNotificationCallback(IMMDeviceEn
 
     LeaveCriticalSection(&g_notif_lock);
 
+    /* Delay create thread as much as possible. */
+    create_update_thread();
+
     return S_OK;
 }
 
diff --git a/libs/faudio/src/FAudio.c b/libs/faudio/src/FAudio.c
index a011e89d89f..b97a8ee6b88 100644
--- a/libs/faudio/src/FAudio.c
+++ b/libs/faudio/src/FAudio.c
@@ -130,6 +130,8 @@ uint32_t FAudioCOMConstructWithCustomAllocatorEXT(
 #ifndef FAUDIO_DISABLE_DEBUGCONFIGURATION
 	FAudio_SetDebugConfiguration(*ppFAudio, &debugInit, NULL);
 #endif /* FAUDIO_DISABLE_DEBUGCONFIGURATION */
+	(*ppFAudio)->platformLock = FAudio_PlatformCreateMutex();
+	LOG_MUTEX_CREATE((*ppFAudio), (*ppFAudio)->platformLock)
 	(*ppFAudio)->sourceLock = FAudio_PlatformCreateMutex();
 	LOG_MUTEX_CREATE((*ppFAudio), (*ppFAudio)->sourceLock)
 	(*ppFAudio)->submixLock = FAudio_PlatformCreateMutex();
@@ -142,6 +144,7 @@ uint32_t FAudioCOMConstructWithCustomAllocatorEXT(
 	(*ppFAudio)->pFree = customFree;
 	(*ppFAudio)->pRealloc = customRealloc;
 	(*ppFAudio)->refcount = 1;
+	(*ppFAudio)->platformFlag = 0;
 	return 0;
 }
 
@@ -182,6 +185,8 @@ uint32_t FAudio_Release(FAudio *audio)
 		audio->pFree(audio->decodeCache);
 		audio->pFree(audio->resampleCache);
 		audio->pFree(audio->effectChainCache);
+		LOG_MUTEX_DESTROY(audio, audio->platformLock)
+		FAudio_PlatformDestroyMutex(audio->platformLock);
 		LOG_MUTEX_DESTROY(audio, audio->sourceLock)
 		FAudio_PlatformDestroyMutex(audio->sourceLock);
 		LOG_MUTEX_DESTROY(audio, audio->submixLock)
@@ -768,6 +773,9 @@ static uint32_t CreateMasteringVoiceImpl(
 		&DATAFORMAT_SUBTYPE_IEEE_FLOAT
 	);
 
+	FAudio_PlatformLockMutex(audio->platformLock);
+	LOG_MUTEX_LOCK(audio, audio->platformLock)
+
 	/* Platform Device */
 	FAudio_PlatformInit(
 		audio,
@@ -781,7 +789,10 @@ static uint32_t CreateMasteringVoiceImpl(
 	if (audio->platform == NULL)
 	{
 		FAudioVoice_DestroyVoice(*ppMasteringVoice);
-		audio->master = *ppMasteringVoice = NULL;
+		*ppMasteringVoice = NULL;
+
+		FAudio_PlatformUnlockMutex(audio->platformLock);
+		LOG_MUTEX_UNLOCK(audio, audio->platformLock)
 
 		/* Not the best code, but it's probably true? */
 		return FAUDIO_E_DEVICE_INVALIDATED;
@@ -799,6 +810,12 @@ static uint32_t CreateMasteringVoiceImpl(
 		);
 	}
 
+	if (audio->platformFlag)
+		FAudio_PlatformAudioThread(audio->platform);
+
+	FAudio_PlatformUnlockMutex(audio->platformLock);
+	LOG_MUTEX_UNLOCK(audio, audio->platformLock)
+
 	return 0;
 }
 
@@ -2420,11 +2437,15 @@ static void destroy_voice(FAudioVoice *voice)
 	}
 	else if (voice->type == FAUDIO_VOICE_MASTER)
 	{
+		FAudio_PlatformLockMutex(voice->audio->platformLock);
+		LOG_MUTEX_LOCK(voice->audio, voice->audio->platformLock)
 		if (voice->audio->platform != NULL)
 		{
 			FAudio_PlatformQuit(voice->audio->platform);
 			voice->audio->platform = NULL;
 		}
+		FAudio_PlatformUnlockMutex(voice->audio->platformLock);
+		LOG_MUTEX_UNLOCK(voice->audio, voice->audio->platformLock)
 		if (voice->master.effectCache != NULL)
 		{
 			voice->audio->pFree(voice->master.effectCache);
@@ -2571,11 +2592,20 @@ uint32_t FAudioSourceVoice_Start(
 		return 0;
 	}
 
-
 	FAudio_assert(voice->type == FAUDIO_VOICE_SOURCE);
 
 	FAudio_assert(Flags == 0);
 	voice->src.active = 1;
+
+	/* Delay create thread as much as possible. */
+	FAudio_PlatformLockMutex(voice->audio->platformLock);
+	LOG_MUTEX_LOCK(voice->audio, voice->audio->platformLock)
+	voice->audio->platformFlag = 1;
+	if (voice->audio->platform)
+		FAudio_PlatformAudioThread(voice->audio->platform);
+	FAudio_PlatformUnlockMutex(voice->audio->platformLock);
+	LOG_MUTEX_UNLOCK(voice->audio, voice->audio->platformLock)
+
 	LOG_API_EXIT(voice->audio)
 	return 0;
 }
@@ -2620,6 +2650,7 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 	uint32_t adpcmMask, *adpcmByteCount;
 	uint32_t playBegin, playLength, loopBegin, loopLength;
 	FAudioBufferEntry *entry, *list;
+	uint32_t status = 0;
 
 	LOG_API_ENTER(voice->audio)
 	LOG_INFO(
@@ -2644,6 +2675,17 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 			(voice->src.wmadec == NULL && (pBufferWMA == NULL && voice->src.format->wFormatTag != FAUDIO_FORMAT_XMAUDIO2))	);
 #endif /* HAVE_WMADEC */
 
+	FAudio_PlatformLockMutex(voice->audio->platformLock);
+	LOG_MUTEX_LOCK(voice->audio, voice->audio->platformLock)
+	if (voice->audio->platform)
+		status = FAudio_PlatformStatus(voice->audio->platform);
+	FAudio_PlatformUnlockMutex(voice->audio->platformLock);
+	LOG_MUTEX_UNLOCK(voice->audio, voice->audio->platformLock)
+	if (status) {
+		LOG_API_EXIT(voice->audio)
+		return status;
+	}
+
 	/* Start off with whatever they just sent us... */
 	playBegin = pBuffer->PlayBegin;
 	playLength = pBuffer->PlayLength;
diff --git a/libs/faudio/src/FAudio_internal.h b/libs/faudio/src/FAudio_internal.h
index ec8301e1025..90239044a6f 100644
--- a/libs/faudio/src/FAudio_internal.h
+++ b/libs/faudio/src/FAudio_internal.h
@@ -462,6 +462,8 @@ struct FAudio
 
 	/* Platform opaque pointer */
 	void *platform;
+	uint32_t platformFlag;
+	FAudioMutex platformLock;
 };
 
 struct FAudioVoice
@@ -801,6 +803,8 @@ void FAudio_PlatformInit(
 	uint32_t *updateSize,
 	void** platformDevice
 );
+void FAudio_PlatformAudioThread(void* platformDevice);
+uint32_t FAudio_PlatformStatus(void* platformDevice);
 void FAudio_PlatformQuit(void* platformDevice);
 
 uint32_t FAudio_PlatformGetDeviceCount(void);
diff --git a/libs/faudio/src/FAudio_platform_win32.c b/libs/faudio/src/FAudio_platform_win32.c
index 3168cbfc50a..e526c201f9e 100644
--- a/libs/faudio/src/FAudio_platform_win32.c
+++ b/libs/faudio/src/FAudio_platform_win32.c
@@ -50,13 +50,6 @@ static CRITICAL_SECTION faudio_cs = { NULL, -1, 0, 0, 0, 0 };
 static IMMDeviceEnumerator *device_enumerator;
 static HRESULT init_hr = -1;
 
-struct FAudioWin32PlatformData
-{
-	IAudioClient *client;
-	HANDLE audioThread;
-	HANDLE stopEvent;
-};
-
 struct FAudioAudioClientThreadArgs
 {
 	WAVEFORMATEXTENSIBLE format;
@@ -66,6 +59,17 @@ struct FAudioAudioClientThreadArgs
 	UINT updateSize;
 };
 
+struct FAudioWin32PlatformData
+{
+	struct FAudioAudioClientThreadArgs *args;
+	FAudio *audio;
+	IAudioClient *client;
+	HANDLE audioThread;
+	HANDLE stopEvent;
+	CRITICAL_SECTION threadCs;
+	REFERENCE_TIME duration;
+};
+
 void FAudio_Log(char const *msg)
 {
 	OutputDebugStringA(msg);
@@ -76,6 +80,12 @@ static HRESULT (WINAPI *my_SetThreadDescription)(HANDLE, PCWSTR) = NULL;
 
 static void FAudio_resolve_SetThreadDescription(void)
 {
+	EnterCriticalSection(&faudio_cs);
+	if (my_SetThreadDescription) {
+		LeaveCriticalSection(&faudio_cs);
+		return;
+	}
+
 	kernelbase = LoadLibraryA("kernelbase.dll");
 	if (!kernelbase)
 		return;
@@ -86,6 +96,7 @@ static void FAudio_resolve_SetThreadDescription(void)
 		FreeLibrary(kernelbase);
 		kernelbase = NULL;
 	}
+	LeaveCriticalSection(&faudio_cs);
 }
 
 static void FAudio_set_thread_name(char const *name)
@@ -93,6 +104,9 @@ static void FAudio_set_thread_name(char const *name)
 	int ret;
 	WCHAR *nameW;
 
+	if (!my_SetThreadDescription)
+		FAudio_resolve_SetThreadDescription();
+
 	if (!my_SetThreadDescription)
 		return;
 
@@ -210,6 +224,8 @@ static DWORD WINAPI FAudio_AudioClientThread(void *user)
 fail_release:
 	IAudioRenderClient_Release(render_client);
 fail_free:
+	CloseHandle(args->events[0]);
+	IAudioClient_Release(args->client);
 	FAudio_free(args);
 	return 0;
 }
@@ -353,6 +369,16 @@ static HRESULT FAudio_OpenDevice(uint32_t deviceIndex, const uint16_t *deviceId,
 		);
 	}
 
+	if (deviceIndex == 0) {
+		/* Default device. */
+		return IMMDeviceEnumerator_GetDefaultAudioEndpoint(
+			device_enumerator,
+			eRender,
+			eConsole,
+			device
+		);
+	}
+
 	hr = IMMDeviceEnumerator_EnumAudioEndpoints(
 		device_enumerator,
 		eRender,
@@ -372,10 +398,7 @@ static HRESULT FAudio_OpenDevice(uint32_t deviceIndex, const uint16_t *deviceId,
 		return hr;
 	}
 
-	if (deviceIndex == 0) {
-		/* Default device. */
-		actualIndex = defaultDeviceIndex;
-	} else if (deviceIndex == defaultDeviceIndex) {
+	if (deviceIndex == defaultDeviceIndex) {
 		/* Open the device at index 0 instead of the "correct" one. */
 		actualIndex = 0;
 	} else {
@@ -395,6 +418,93 @@ static HRESULT FAudio_OpenDevice(uint32_t deviceIndex, const uint16_t *deviceId,
 	return hr;
 }
 
+uint32_t FAudio_PlatformStatus(void* platformDevice) {
+	struct FAudioWin32PlatformData *data = platformDevice;
+	uint32_t status = 0;
+	DWORD threadStatus = 0;
+	EnterCriticalSection(&data->threadCs);
+	if (
+		!data->args ||
+		(
+			data->audioThread &&
+			(!GetExitCodeThread(data->audioThread, &threadStatus) || threadStatus != STILL_ACTIVE)
+		)
+	)
+		status = FAUDIO_E_DEVICE_INVALIDATED;
+	LeaveCriticalSection(&data->threadCs);
+	return status;
+}
+
+void FAudio_PlatformAudioThread(void* platformDevice) {
+	HRESULT hr;
+	struct FAudioWin32PlatformData *data = platformDevice;
+	struct FAudioAudioClientThreadArgs *args = data->args;
+
+	HANDLE audioEvent = NULL;
+
+	EnterCriticalSection(&data->threadCs);
+	if (!data->args || data->audioThread) {
+		LeaveCriticalSection(&data->threadCs);
+		return;
+	}
+
+	audioEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+	if (!audioEvent)
+		/* Failed to create FAudio thread buffer event! */
+		goto fail_args;
+
+	data->stopEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+	if (!data->stopEvent)
+		/* Failed to create FAudio thread stop event! */
+		goto fail_close_audio_evt;
+
+	args->client = data->client;
+	args->events[0] = audioEvent;
+	args->events[1] = data->stopEvent;
+	args->audio = data->audio;
+
+	hr = IAudioClient_Initialize(
+		data->client,
+		AUDCLNT_SHAREMODE_SHARED,
+		AUDCLNT_STREAMFLAGS_EVENTCALLBACK,
+		data->duration * 3,
+		0,
+		&args->format.Format,
+		&GUID_NULL
+	);
+	if (FAILED(hr))
+		/* Failed to initialize audio client! */
+		goto fail_close_stop_evt;
+
+	hr = IAudioClient_SetEventHandle(data->client, audioEvent);
+	if (FAILED(hr))
+		/* Failed to set audio client event! */
+		goto fail_close_stop_evt;
+
+
+	data->audioThread = CreateThread(NULL, 0, &FAudio_AudioClientThread, args, 0, NULL);
+	if (!data->audioThread)
+		/* Failed to create audio client thread! */
+		goto fail_close_stop_evt;
+
+	data->client = NULL;
+	LeaveCriticalSection(&data->threadCs);
+	return;
+
+fail_close_stop_evt:
+	CloseHandle(data->stopEvent);
+	data->stopEvent = NULL;
+fail_close_audio_evt:
+	CloseHandle(audioEvent);
+fail_args:
+	IAudioClient_Release(data->client);
+	data->client = NULL;
+	FAudio_free(data->args);
+	data->args = NULL;
+	LeaveCriticalSection(&data->threadCs);
+	return;
+}
+
 void FAudio_PlatformInit(
 	FAudio *audio,
 	uint32_t flags,
@@ -406,11 +516,9 @@ void FAudio_PlatformInit(
 ) {
 	struct FAudioAudioClientThreadArgs *args;
 	struct FAudioWin32PlatformData *data;
-	REFERENCE_TIME duration;
 	WAVEFORMATEX *closest;
 	IMMDevice *device = NULL;
 	HRESULT hr;
-	HANDLE audioEvent = NULL;
 	BOOL has_sse2 = IsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE);
 #if defined(__aarch64__) || defined(_M_ARM64) || defined(__arm64ec__) || defined(_M_ARM64EC)
 	BOOL has_neon = TRUE;
@@ -420,7 +528,6 @@ void FAudio_PlatformInit(
 	BOOL has_neon = FALSE;
 #endif
 	FAudio_INTERNAL_InitSIMDFunctions(has_sse2, has_neon);
-	FAudio_resolve_SetThreadDescription();
 
 	FAudio_PlatformAddRef();
 
@@ -456,20 +563,10 @@ void FAudio_PlatformInit(
 		);
 	}
 
-	audioEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
-	if (!audioEvent)
-		/* Failed to create FAudio thread buffer event! */
-		goto fail_free_data;
-
-	data->stopEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
-	if (!data->stopEvent)
-		/* Failed to create FAudio thread stop event! */
-		goto fail_close_audio_evt;
-
 	hr = FAudio_OpenDevice(deviceIndex, deviceId, &device);
 	if (!device)
 		/* Failed to get audio device! */
-		goto fail_close_stop_evt;
+		goto fail_free_data;
 
 	hr = IMMDevice_Activate(
 		device,
@@ -483,8 +580,8 @@ void FAudio_PlatformInit(
 		goto fail_device;
 	IMMDevice_Release(device);
 
-	if (flags & FAUDIO_1024_QUANTUM) duration = 213333;
-	else duration = 100000;
+	if (flags & FAUDIO_1024_QUANTUM) data->duration = 213333;
+	else data->duration = 100000;
 
 	hr = IAudioClient_IsFormatSupported(
 		data->client,
@@ -503,24 +600,6 @@ void FAudio_PlatformInit(
 		CoTaskMemFree(closest);
 	}
 
-	hr = IAudioClient_Initialize(
-		data->client,
-		AUDCLNT_SHAREMODE_SHARED,
-		AUDCLNT_STREAMFLAGS_EVENTCALLBACK,
-		duration * 3,
-		0,
-		&args->format.Format,
-		&GUID_NULL
-	);
-	if (FAILED(hr))
-		/* Failed to initialize audio client! */
-		goto fail_audio;
-
-	hr = IAudioClient_SetEventHandle(data->client, audioEvent);
-	if (FAILED(hr))
-		/* Failed to set audio client event! */
-		goto fail_audio;
-
 	mixFormat->Format.wFormatTag = args->format.Format.wFormatTag;
 	mixFormat->Format.nChannels = args->format.Format.nChannels;
 	mixFormat->Format.nSamplesPerSec = args->format.Format.nSamplesPerSec;
@@ -544,18 +623,13 @@ void FAudio_PlatformInit(
 		mixFormat->Format.cbSize = sizeof(FAudioWaveFormatEx);
 	}
 
-	args->client = data->client;
-	args->events[0] = audioEvent;
-	args->events[1] = data->stopEvent;
-	args->audio = audio;
+	data->audio = audio;
+	data->args = args;
+	InitializeCriticalSection(&data->threadCs);
+
 	if (flags & FAUDIO_1024_QUANTUM) args->updateSize = args->format.Format.nSamplesPerSec / (1000.0 / (64.0 / 3.0));
 	else args->updateSize = args->format.Format.nSamplesPerSec / 100;
 
-	data->audioThread = CreateThread(NULL, 0, &FAudio_AudioClientThread, args, 0, NULL);
-	if (!data->audioThread)
-		/* Failed to create audio client thread! */
-		goto fail_audio;
-
 	*updateSize = args->updateSize;
 	*platformDevice = data;
 	return;
@@ -564,10 +638,6 @@ fail_audio:
 	IAudioClient_Release(data->client);
 fail_device:
 	IMMDevice_Release(device);
-fail_close_stop_evt:
-	CloseHandle(data->stopEvent);
-fail_close_audio_evt:
-	CloseHandle(audioEvent);
 fail_free_data:
 	FAudio_free(data);
 fail_free_args:
@@ -581,9 +651,25 @@ void FAudio_PlatformQuit(void* platformDevice)
 {
 	struct FAudioWin32PlatformData *data = platformDevice;
 
-	SetEvent(data->stopEvent);
-	WaitForSingleObject(data->audioThread, INFINITE);
-	if (data->client) IAudioClient_Release(data->client);
+	EnterCriticalSection(&data->threadCs);
+	if (data->audioThread) {
+		if (data->stopEvent)
+			SetEvent(data->stopEvent);
+		WaitForSingleObject(data->audioThread, INFINITE);
+		CloseHandle(data->audioThread);
+		data->audioThread = NULL;
+	}
+	LeaveCriticalSection(&data->threadCs);
+	DeleteCriticalSection(&data->threadCs);
+	if (data->stopEvent) {
+		CloseHandle(data->stopEvent);
+		data->stopEvent = NULL;
+	}
+	if (data->client) {
+		IAudioClient_Release(data->client);
+		data->client = NULL;
+	}
+	FAudio_free(data);
 	if (kernelbase)
 	{
 		my_SetThreadDescription = NULL;
@@ -712,15 +798,6 @@ uint32_t FAudio_PlatformGetDeviceDetails(
 		IMMDevice_Release(device);
 		device = NULL;
 	}
-	else
-	{
-		count = FAudio_PlatformGetDeviceCount();
-		if (index >= count)
-		{
-			ret = FAUDIO_E_INVALID_CALL;
-			goto fail_release;
-		}
-	}
 
 	hr = FAudio_OpenDevice(index, deviceId, &device);
 	if (FAILED(hr))
-- 
2.52.0

