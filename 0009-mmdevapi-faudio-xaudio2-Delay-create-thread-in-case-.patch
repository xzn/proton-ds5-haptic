From ab0ec63866e9149f8692f2ed71a8a4e46ba713ca Mon Sep 17 00:00:00 2001
From: JS Deck <jsdeckerido@gmail.com>
Date: Wed, 10 Dec 2025 23:09:50 -0400
Subject: [PATCH 9/9] mmdevapi/faudio/xaudio2: Delay create thread in case of
 functions being called in dllmain; delay kernelbase resolve; get default
 audio endpoint directly.

---
 dlls/mmdevapi/devenum.c                 |   7 +-
 libs/faudio/src/FAudio.c                |  31 +++-
 libs/faudio/src/FAudio_internal.h       |   2 +
 libs/faudio/src/FAudio_platform_win32.c | 183 +++++++++++++++---------
 4 files changed, 150 insertions(+), 73 deletions(-)

diff --git a/dlls/mmdevapi/devenum.c b/dlls/mmdevapi/devenum.c
index 6df43ca93ee..b0268833f03 100644
--- a/dlls/mmdevapi/devenum.c
+++ b/dlls/mmdevapi/devenum.c
@@ -1520,9 +1520,6 @@ static HRESULT WINAPI MMDevEnum_QueryInterface(IMMDeviceEnumerator *iface, REFII
     if (!*ppv)
         return E_NOINTERFACE;
     IUnknown_AddRef((IUnknown*)*ppv);
-
-    create_update_thread();
-
     return S_OK;
 }
 
@@ -1852,6 +1849,10 @@ static HRESULT WINAPI MMDevEnum_RegisterEndpointNotificationCallback(IMMDeviceEn
 
     LeaveCriticalSection(&g_notif_lock);
 
+    /* Delay create thread as much as possible. */
+    /* mmdevenum create may get called in dllmain, let's hope this doesn't get called in dllmain. */
+    create_update_thread();
+
     return S_OK;
 }
 
diff --git a/libs/faudio/src/FAudio.c b/libs/faudio/src/FAudio.c
index a011e89d89f..f19ef09b60f 100644
--- a/libs/faudio/src/FAudio.c
+++ b/libs/faudio/src/FAudio.c
@@ -130,6 +130,8 @@ uint32_t FAudioCOMConstructWithCustomAllocatorEXT(
 #ifndef FAUDIO_DISABLE_DEBUGCONFIGURATION
 	FAudio_SetDebugConfiguration(*ppFAudio, &debugInit, NULL);
 #endif /* FAUDIO_DISABLE_DEBUGCONFIGURATION */
+	(*ppFAudio)->platformLock = FAudio_PlatformCreateMutex();
+	LOG_MUTEX_CREATE((*ppFAudio), (*ppFAudio)->platformLock)
 	(*ppFAudio)->sourceLock = FAudio_PlatformCreateMutex();
 	LOG_MUTEX_CREATE((*ppFAudio), (*ppFAudio)->sourceLock)
 	(*ppFAudio)->submixLock = FAudio_PlatformCreateMutex();
@@ -182,6 +184,8 @@ uint32_t FAudio_Release(FAudio *audio)
 		audio->pFree(audio->decodeCache);
 		audio->pFree(audio->resampleCache);
 		audio->pFree(audio->effectChainCache);
+		LOG_MUTEX_DESTROY(audio, audio->platformLock)
+		FAudio_PlatformDestroyMutex(audio->platformLock);
 		LOG_MUTEX_DESTROY(audio, audio->sourceLock)
 		FAudio_PlatformDestroyMutex(audio->sourceLock);
 		LOG_MUTEX_DESTROY(audio, audio->submixLock)
@@ -586,6 +590,15 @@ uint32_t FAudio_CreateSourceVoice(
 		audio->pMalloc
 	);
 
+	/* Delay create thread as much as possible. */
+	/* CreateMasteringVoice gets called in dllmain sometimes. */
+	FAudio_PlatformLockMutex(audio->platformLock);
+	LOG_MUTEX_LOCK(audio, audio->platformLock)
+	if (audio->platform)
+		FAudio_PlatformCreateAudioThread(audio->platform);
+	FAudio_PlatformUnlockMutex(audio->platformLock);
+	LOG_MUTEX_UNLOCK(audio, audio->platformLock)
+
 #ifdef FAUDIO_DUMP_VOICES
 	FAudio_DUMPVOICE_Init(*ppSourceVoice);
 #endif /* FAUDIO_DUMP_VOICES */
@@ -768,6 +781,9 @@ static uint32_t CreateMasteringVoiceImpl(
 		&DATAFORMAT_SUBTYPE_IEEE_FLOAT
 	);
 
+	FAudio_PlatformLockMutex(audio->platformLock);
+	LOG_MUTEX_LOCK(audio, audio->platformLock)
+
 	/* Platform Device */
 	FAudio_PlatformInit(
 		audio,
@@ -781,7 +797,10 @@ static uint32_t CreateMasteringVoiceImpl(
 	if (audio->platform == NULL)
 	{
 		FAudioVoice_DestroyVoice(*ppMasteringVoice);
-		audio->master = *ppMasteringVoice = NULL;
+		*ppMasteringVoice = NULL;
+
+		FAudio_PlatformUnlockMutex(audio->platformLock);
+		LOG_MUTEX_UNLOCK(audio, audio->platformLock)
 
 		/* Not the best code, but it's probably true? */
 		return FAUDIO_E_DEVICE_INVALIDATED;
@@ -799,6 +818,12 @@ static uint32_t CreateMasteringVoiceImpl(
 		);
 	}
 
+	if (audio->sources)
+		FAudio_PlatformCreateAudioThread(audio->platform);
+
+	FAudio_PlatformUnlockMutex(audio->platformLock);
+	LOG_MUTEX_UNLOCK(audio, audio->platformLock)
+
 	return 0;
 }
 
@@ -2420,11 +2445,15 @@ static void destroy_voice(FAudioVoice *voice)
 	}
 	else if (voice->type == FAUDIO_VOICE_MASTER)
 	{
+		FAudio_PlatformLockMutex(voice->audio->platformLock);
+		LOG_MUTEX_LOCK(voice->audio, voice->audio->platformLock)
 		if (voice->audio->platform != NULL)
 		{
 			FAudio_PlatformQuit(voice->audio->platform);
 			voice->audio->platform = NULL;
 		}
+		FAudio_PlatformUnlockMutex(voice->audio->platformLock);
+		LOG_MUTEX_UNLOCK(voice->audio, voice->audio->platformLock)
 		if (voice->master.effectCache != NULL)
 		{
 			voice->audio->pFree(voice->master.effectCache);
diff --git a/libs/faudio/src/FAudio_internal.h b/libs/faudio/src/FAudio_internal.h
index ec8301e1025..994a37c8fa9 100644
--- a/libs/faudio/src/FAudio_internal.h
+++ b/libs/faudio/src/FAudio_internal.h
@@ -462,6 +462,7 @@ struct FAudio
 
 	/* Platform opaque pointer */
 	void *platform;
+	FAudioMutex platformLock;
 };
 
 struct FAudioVoice
@@ -801,6 +802,7 @@ void FAudio_PlatformInit(
 	uint32_t *updateSize,
 	void** platformDevice
 );
+void FAudio_PlatformCreateAudioThread(void* platformDevice);
 void FAudio_PlatformQuit(void* platformDevice);
 
 uint32_t FAudio_PlatformGetDeviceCount(void);
diff --git a/libs/faudio/src/FAudio_platform_win32.c b/libs/faudio/src/FAudio_platform_win32.c
index 3168cbfc50a..5c7fcdb661d 100644
--- a/libs/faudio/src/FAudio_platform_win32.c
+++ b/libs/faudio/src/FAudio_platform_win32.c
@@ -50,13 +50,6 @@ static CRITICAL_SECTION faudio_cs = { NULL, -1, 0, 0, 0, 0 };
 static IMMDeviceEnumerator *device_enumerator;
 static HRESULT init_hr = -1;
 
-struct FAudioWin32PlatformData
-{
-	IAudioClient *client;
-	HANDLE audioThread;
-	HANDLE stopEvent;
-};
-
 struct FAudioAudioClientThreadArgs
 {
 	WAVEFORMATEXTENSIBLE format;
@@ -66,6 +59,17 @@ struct FAudioAudioClientThreadArgs
 	UINT updateSize;
 };
 
+struct FAudioWin32PlatformData
+{
+	struct FAudioAudioClientThreadArgs *args;
+	FAudio *audio;
+	IAudioClient *client;
+	HANDLE audioThread;
+	HANDLE stopEvent;
+	CRITICAL_SECTION threadCs;
+	REFERENCE_TIME duration;
+};
+
 void FAudio_Log(char const *msg)
 {
 	OutputDebugStringA(msg);
@@ -76,6 +80,12 @@ static HRESULT (WINAPI *my_SetThreadDescription)(HANDLE, PCWSTR) = NULL;
 
 static void FAudio_resolve_SetThreadDescription(void)
 {
+	EnterCriticalSection(&faudio_cs);
+	if (my_SetThreadDescription) {
+		LeaveCriticalSection(&faudio_cs);
+		return;
+	}
+
 	kernelbase = LoadLibraryA("kernelbase.dll");
 	if (!kernelbase)
 		return;
@@ -86,6 +96,7 @@ static void FAudio_resolve_SetThreadDescription(void)
 		FreeLibrary(kernelbase);
 		kernelbase = NULL;
 	}
+	LeaveCriticalSection(&faudio_cs);
 }
 
 static void FAudio_set_thread_name(char const *name)
@@ -93,6 +104,9 @@ static void FAudio_set_thread_name(char const *name)
 	int ret;
 	WCHAR *nameW;
 
+	if (!my_SetThreadDescription)
+		FAudio_resolve_SetThreadDescription();
+
 	if (!my_SetThreadDescription)
 		return;
 
@@ -210,6 +224,7 @@ static DWORD WINAPI FAudio_AudioClientThread(void *user)
 fail_release:
 	IAudioRenderClient_Release(render_client);
 fail_free:
+	CloseHandle(args->events[0]);
 	FAudio_free(args);
 	return 0;
 }
@@ -353,6 +368,16 @@ static HRESULT FAudio_OpenDevice(uint32_t deviceIndex, const uint16_t *deviceId,
 		);
 	}
 
+	if (deviceIndex == 0) {
+		/* Default device. */
+		return IMMDeviceEnumerator_GetDefaultAudioEndpoint(
+			device_enumerator,
+			eRender,
+			eConsole,
+			device
+		);
+	}
+
 	hr = IMMDeviceEnumerator_EnumAudioEndpoints(
 		device_enumerator,
 		eRender,
@@ -372,10 +397,7 @@ static HRESULT FAudio_OpenDevice(uint32_t deviceIndex, const uint16_t *deviceId,
 		return hr;
 	}
 
-	if (deviceIndex == 0) {
-		/* Default device. */
-		actualIndex = defaultDeviceIndex;
-	} else if (deviceIndex == defaultDeviceIndex) {
+	if (deviceIndex == defaultDeviceIndex) {
 		/* Open the device at index 0 instead of the "correct" one. */
 		actualIndex = 0;
 	} else {
@@ -395,6 +417,70 @@ static HRESULT FAudio_OpenDevice(uint32_t deviceIndex, const uint16_t *deviceId,
 	return hr;
 }
 
+void FAudio_PlatformCreateAudioThread(void* platformDevice) {
+	HRESULT hr;
+	struct FAudioWin32PlatformData *data = platformDevice;
+	struct FAudioAudioClientThreadArgs *args = data->args;
+
+	HANDLE audioEvent = NULL;
+
+	EnterCriticalSection(&data->threadCs);
+	if (data->audioThread) {
+		LeaveCriticalSection(&data->threadCs);
+		return;
+	}
+
+	audioEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+	if (!audioEvent)
+		/* Failed to create FAudio thread buffer event! */
+		goto fail;
+
+	data->stopEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+	if (!data->stopEvent)
+		/* Failed to create FAudio thread stop event! */
+		goto fail_close_audio_evt;
+
+	args->client = data->client;
+	args->events[0] = audioEvent;
+	args->events[1] = data->stopEvent;
+	args->audio = data->audio;
+
+	hr = IAudioClient_Initialize(
+		data->client,
+		AUDCLNT_SHAREMODE_SHARED,
+		AUDCLNT_STREAMFLAGS_EVENTCALLBACK,
+		data->duration * 3,
+		0,
+		&args->format.Format,
+		&GUID_NULL
+	);
+	if (FAILED(hr))
+		/* Failed to initialize audio client! */
+		goto fail_close_stop_evt;
+
+	hr = IAudioClient_SetEventHandle(data->client, audioEvent);
+	if (FAILED(hr))
+		/* Failed to set audio client event! */
+		goto fail_close_stop_evt;
+
+
+	data->audioThread = CreateThread(NULL, 0, &FAudio_AudioClientThread, args, 0, NULL);
+	if (!data->audioThread)
+		/* Failed to create audio client thread! */
+		goto fail_close_stop_evt;
+
+	LeaveCriticalSection(&data->threadCs);
+	return;
+
+fail_close_stop_evt:
+	CloseHandle(data->stopEvent);
+fail_close_audio_evt:
+	CloseHandle(audioEvent);
+fail:
+	LeaveCriticalSection(&data->threadCs);
+	return;
+}
+
 void FAudio_PlatformInit(
 	FAudio *audio,
 	uint32_t flags,
@@ -406,11 +492,9 @@ void FAudio_PlatformInit(
 ) {
 	struct FAudioAudioClientThreadArgs *args;
 	struct FAudioWin32PlatformData *data;
-	REFERENCE_TIME duration;
 	WAVEFORMATEX *closest;
 	IMMDevice *device = NULL;
 	HRESULT hr;
-	HANDLE audioEvent = NULL;
 	BOOL has_sse2 = IsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE);
 #if defined(__aarch64__) || defined(_M_ARM64) || defined(__arm64ec__) || defined(_M_ARM64EC)
 	BOOL has_neon = TRUE;
@@ -420,7 +504,6 @@ void FAudio_PlatformInit(
 	BOOL has_neon = FALSE;
 #endif
 	FAudio_INTERNAL_InitSIMDFunctions(has_sse2, has_neon);
-	FAudio_resolve_SetThreadDescription();
 
 	FAudio_PlatformAddRef();
 
@@ -456,20 +539,10 @@ void FAudio_PlatformInit(
 		);
 	}
 
-	audioEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
-	if (!audioEvent)
-		/* Failed to create FAudio thread buffer event! */
-		goto fail_free_data;
-
-	data->stopEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
-	if (!data->stopEvent)
-		/* Failed to create FAudio thread stop event! */
-		goto fail_close_audio_evt;
-
 	hr = FAudio_OpenDevice(deviceIndex, deviceId, &device);
 	if (!device)
 		/* Failed to get audio device! */
-		goto fail_close_stop_evt;
+		goto fail_free_data;
 
 	hr = IMMDevice_Activate(
 		device,
@@ -483,8 +556,8 @@ void FAudio_PlatformInit(
 		goto fail_device;
 	IMMDevice_Release(device);
 
-	if (flags & FAUDIO_1024_QUANTUM) duration = 213333;
-	else duration = 100000;
+	if (flags & FAUDIO_1024_QUANTUM) data->duration = 213333;
+	else data->duration = 100000;
 
 	hr = IAudioClient_IsFormatSupported(
 		data->client,
@@ -503,24 +576,6 @@ void FAudio_PlatformInit(
 		CoTaskMemFree(closest);
 	}
 
-	hr = IAudioClient_Initialize(
-		data->client,
-		AUDCLNT_SHAREMODE_SHARED,
-		AUDCLNT_STREAMFLAGS_EVENTCALLBACK,
-		duration * 3,
-		0,
-		&args->format.Format,
-		&GUID_NULL
-	);
-	if (FAILED(hr))
-		/* Failed to initialize audio client! */
-		goto fail_audio;
-
-	hr = IAudioClient_SetEventHandle(data->client, audioEvent);
-	if (FAILED(hr))
-		/* Failed to set audio client event! */
-		goto fail_audio;
-
 	mixFormat->Format.wFormatTag = args->format.Format.wFormatTag;
 	mixFormat->Format.nChannels = args->format.Format.nChannels;
 	mixFormat->Format.nSamplesPerSec = args->format.Format.nSamplesPerSec;
@@ -544,18 +599,13 @@ void FAudio_PlatformInit(
 		mixFormat->Format.cbSize = sizeof(FAudioWaveFormatEx);
 	}
 
-	args->client = data->client;
-	args->events[0] = audioEvent;
-	args->events[1] = data->stopEvent;
-	args->audio = audio;
+	data->audio = audio;
+	data->args = args;
+	InitializeCriticalSection(&data->threadCs);
+
 	if (flags & FAUDIO_1024_QUANTUM) args->updateSize = args->format.Format.nSamplesPerSec / (1000.0 / (64.0 / 3.0));
 	else args->updateSize = args->format.Format.nSamplesPerSec / 100;
 
-	data->audioThread = CreateThread(NULL, 0, &FAudio_AudioClientThread, args, 0, NULL);
-	if (!data->audioThread)
-		/* Failed to create audio client thread! */
-		goto fail_audio;
-
 	*updateSize = args->updateSize;
 	*platformDevice = data;
 	return;
@@ -564,10 +614,6 @@ fail_audio:
 	IAudioClient_Release(data->client);
 fail_device:
 	IMMDevice_Release(device);
-fail_close_stop_evt:
-	CloseHandle(data->stopEvent);
-fail_close_audio_evt:
-	CloseHandle(audioEvent);
 fail_free_data:
 	FAudio_free(data);
 fail_free_args:
@@ -581,9 +627,17 @@ void FAudio_PlatformQuit(void* platformDevice)
 {
 	struct FAudioWin32PlatformData *data = platformDevice;
 
-	SetEvent(data->stopEvent);
-	WaitForSingleObject(data->audioThread, INFINITE);
+	EnterCriticalSection(&data->threadCs);
+	if (data->audioThread) {
+		if (data->stopEvent)
+			SetEvent(data->stopEvent);
+		WaitForSingleObject(data->audioThread, INFINITE);
+	}
+	LeaveCriticalSection(&data->threadCs);
+	DeleteCriticalSection(&data->threadCs);
+	CloseHandle(data->stopEvent);
 	if (data->client) IAudioClient_Release(data->client);
+	FAudio_free(data);
 	if (kernelbase)
 	{
 		my_SetThreadDescription = NULL;
@@ -712,15 +766,6 @@ uint32_t FAudio_PlatformGetDeviceDetails(
 		IMMDevice_Release(device);
 		device = NULL;
 	}
-	else
-	{
-		count = FAudio_PlatformGetDeviceCount();
-		if (index >= count)
-		{
-			ret = FAUDIO_E_INVALID_CALL;
-			goto fail_release;
-		}
-	}
 
 	hr = FAudio_OpenDevice(index, deviceId, &device);
 	if (FAILED(hr))
-- 
2.52.0

